<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GPS 도보 테스터 (GPS 수신 수정완료)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalmanjs@1.1.0/dist/kalman.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .btn:active { transform: scale(0.97); }
        .map-canvas { background-color: #1a202c; }
        .compass { 
            width: 60px; 
            height: 60px; 
            border: 2px solid #10B981; 
            border-radius: 50%; 
            position: relative; 
            background: rgba(0,0,0,0.7);
        }
        .compass::before { 
            content: '📱'; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 16px;
        }
        .direction-arrow { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: 2px; 
            height: 25px; 
            background: #EF4444; 
            transform-origin: bottom center; 
            transform: translate(-50%, -100%);
        }
        .direction-arrow::before { 
            content: '▲'; 
            position: absolute; 
            top: -8px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: #EF4444; 
            font-size: 12px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center h-screen p-2 sm:p-4">

    <div class="w-full max-w-lg mx-auto flex flex-col h-full">
        <header class="text-center py-2">
            <h1 class="text-2xl font-bold text-cyan-400">GPS 도보 테스터 (GPS 수신 수정완료)</h1>
            <p id="app-status" class="text-gray-400 text-sm">GPS 신호를 기다리는 중...</p>
        </header>

        <div class="relative w-full flex-grow rounded-xl overflow-hidden border-2 border-cyan-500/30 my-2">
            <canvas id="mapCanvas" class="map-canvas"></canvas>
            <div class="absolute bottom-2 left-2 bg-black/50 p-2 rounded-lg text-xs leading-tight">
                <p><span class="text-green-400">🟢</span> 현재 위치 (칼만 필터)</p>
                <p><span class="text-blue-400">🔵</span> 웨이포인트</p>
                <p><span class="text-yellow-400">★</span> 최고 신호 지점</p>
            </div>
            <div class="absolute top-2 right-2 bg-black/50 p-2 rounded-full text-xs text-center font-sans">
                <div class="font-bold">N</div>
                <div>⬆</div>
            </div>
            <!-- 방향 나침반 -->
            <div class="absolute top-2 left-2 bg-black/50 p-2 rounded-lg">
                <div class="compass" id="compass">
                    <div class="direction-arrow" id="direction-arrow"></div>
                </div>
                <div class="text-xs text-center mt-1">
                    <div>방향: <span id="bearing-display" class="text-cyan-400">0°</span></div>
                    <div>폰: <span id="phone-heading" class="text-green-400">0°</span></div>
                </div>
            </div>
        </div>

        <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
            <div id="status-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-3 text-sm mb-4">
                <div><span class="text-gray-400">상대 위치:</span> <span id="current-meter-display" class="font-mono text-white">(0.0, 0.0)m</span></div>
                <div><span class="text-gray-400">목표까지:</span> <span id="distance-display" class="font-mono font-bold text-green-400">0.0 m</span></div>
                <div><span class="text-gray-400">총 이동 거리:</span> <span id="total-distance-display" class="font-mono text-white">0.0 m</span></div>
                <div><span class="text-gray-400">알고리즘:</span> <span id="state-display" class="font-mono text-yellow-300">IDLE</span></div>
                <div><span class="text-gray-400">Stuck:</span> <span id="stuck-display" class="font-mono text-red-400">0</span></div>
                <div><span class="text-gray-400">최고 신호:</span> <span id="best-signal-display" class="font-mono text-yellow-400">-100.0 dBm</span></div>
                <div><span class="text-gray-400">추정 속도:</span> <span id="velocity-display" class="font-mono text-cyan-400">0.00 m/s</span></div>
                <div><span class="text-gray-400">필터 상태:</span> <span id="filter-status" class="font-mono text-purple-400">초기화 중</span></div>
            </div>

            <div id="log-section" class="hidden my-3">
                 <button id="download-log-button" class="btn w-full bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg text-sm">
                    로그 다운로드 (<span id="log-count">0</span>개 기록)
                </button>
            </div>
            
            <div id="control-section" class="hidden">
                <label for="rssi-input" class="block mb-2 text-base font-medium text-green-300">목표 도착! RSSI 값을 입력하세요:</label>
                <input type="number" id="rssi-input" class="bg-gray-700 border border-gray-600 text-white text-2xl font-bold rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-full p-3 text-center mb-3" placeholder="-55">
                <button id="submit-rssi-button" class="btn w-full text-white bg-green-500 hover:bg-green-600 font-bold rounded-lg text-lg px-5 py-3 transition-transform">
                    다음 목표 계산
                </button>
            </div>
             <button id="start-button" class="btn w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-6 rounded-lg text-lg">테스트 시작</button>
        </div>
    </div>

    <script>
        // 칼만 필터 클래스 구현
        class KalmanFilter {
            constructor() {
                // 상태 벡터: [x, y, vx, vy] (위치와 속도)
                this.state = [0, 0, 0, 0];
                
                // 상태 공분산 매트릭스 (4x4)
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10]
                ];
                
                // 상태 전이 매트릭스 F (시간 dt는 동적으로 설정)
                this.F = null;
                
                // 측정 매트릭스 H (위치만 측정)
                this.H = [
                    [1, 0, 0, 0],
                    [0, 1, 0, 0]
                ];
                
                // 프로세스 노이즈 공분산 매트릭스 Q
                this.Q = null;
                
                // 측정 노이즈 공분산 매트릭스 R
                this.R = [
                    [25, 0],    // GPS 정확도 ~5m 기준
                    [0, 25]
                ];
                
                this.lastTime = null;
                this.initialized = false;
            }
            
            // 매트릭스 곱셈
            matrixMultiply(A, B) {
                const rows = A.length;
                const cols = B[0].length;
                const inner = B.length;
                const result = Array(rows).fill().map(() => Array(cols).fill(0));
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        for (let k = 0; k < inner; k++) {
                            result[i][j] += A[i][k] * B[k][j];
                        }
                    }
                }
                return result;
            }
            
            // 매트릭스 덧셈
            matrixAdd(A, B) {
                return A.map((row, i) => row.map((val, j) => val + B[i][j]));
            }
            
            // 매트릭스 뺄셈
            matrixSubtract(A, B) {
                return A.map((row, i) => row.map((val, j) => val - B[i][j]));
            }
            
            // 매트릭스 전치
            matrixTranspose(A) {
                return A[0].map((_, colIndex) => A.map(row => row[colIndex]));
            }
            
            // 2x2 매트릭스 역행렬
            matrix2x2Inverse(A) {
                const det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
                if (Math.abs(det) < 1e-10) {
                    // 특이행렬인 경우 단위행렬 반환
                    return [[1, 0], [0, 1]];
                }
                return [
                    [A[1][1] / det, -A[0][1] / det],
                    [-A[1][0] / det, A[0][0] / det]
                ];
            }
            
            // 칼만 필터 예측 단계
            predict(dt) {
                if (!this.initialized) return;
                
                // 상태 전이 매트릭스 F 업데이트
                this.F = [
                    [1, 0, dt, 0],
                    [0, 1, 0, dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                ];
                
                // 프로세스 노이즈 공분산 매트릭스 Q 업데이트
                const dt2 = dt * dt;
                const dt3 = dt2 * dt;
                const dt4 = dt3 * dt;
                const q = 0.5; // 프로세스 노이즈 강도
                
                this.Q = [
                    [dt4 * q / 4, 0, dt3 * q / 2, 0],
                    [0, dt4 * q / 4, 0, dt3 * q / 2],
                    [dt3 * q / 2, 0, dt2 * q, 0],
                    [0, dt3 * q / 2, 0, dt2 * q]
                ];
                
                // 상태 예측: x = F * x
                const F_x = this.matrixMultiply(this.F, [[this.state[0]], [this.state[1]], [this.state[2]], [this.state[3]]]);
                this.state = [F_x[0][0], F_x[1][0], F_x[2][0], F_x[3][0]];
                
                // 공분산 예측: P = F * P * F' + Q
                const F_P = this.matrixMultiply(this.F, this.P);
                const F_P_Ft = this.matrixMultiply(F_P, this.matrixTranspose(this.F));
                this.P = this.matrixAdd(F_P_Ft, this.Q);
            }
            
            // 칼만 필터 업데이트 단계
            update(measurement) {
                const currentTime = Date.now();
                
                if (!this.initialized) {
                    // 첫 번째 측정값으로 초기화
                    this.state = [measurement[0], measurement[1], 0, 0];
                    this.initialized = true;
                    this.lastTime = currentTime;
                    return this.state.slice(0, 2); // 위치만 반환
                }
                
                // 시간 간격 계산
                const dt = Math.min((currentTime - this.lastTime) / 1000.0, 1.0); // 최대 1초
                this.lastTime = currentTime;
                
                // 예측 단계
                this.predict(dt);
                
                // 측정 잔차: y = z - H * x
                const H_x = this.matrixMultiply(this.H, [[this.state[0]], [this.state[1]], [this.state[2]], [this.state[3]]]);
                const y = [
                    [measurement[0] - H_x[0][0]],
                    [measurement[1] - H_x[1][0]]
                ];
                
                // 잔차 공분산: S = H * P * H' + R
                const H_P = this.matrixMultiply(this.H, this.P);
                const H_P_Ht = this.matrixMultiply(H_P, this.matrixTranspose(this.H));
                const S = this.matrixAdd(H_P_Ht, this.R);
                
                // 칼만 게인: K = P * H' * S^(-1)
                const P_Ht = this.matrixMultiply(this.P, this.matrixTranspose(this.H));
                const S_inv = this.matrix2x2Inverse(S);
                const K = this.matrixMultiply(P_Ht, S_inv);
                
                // 상태 업데이트: x = x + K * y
                const K_y = this.matrixMultiply(K, y);
                this.state[0] += K_y[0][0];
                this.state[1] += K_y[1][0];
                this.state[2] += K_y[2][0];
                this.state[3] += K_y[3][0];
                
                // 공분산 업데이트: P = (I - K * H) * P
                const I = [
                    [1, 0, 0, 0],
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                ];
                const K_H = this.matrixMultiply(K, this.H);
                const I_KH = this.matrixSubtract(I, K_H);
                this.P = this.matrixMultiply(I_KH, this.P);
                
                return this.state.slice(0, 2); // 위치만 반환 [x, y]
            }
            
            // 현재 추정 속도 반환 (m/s)
            getVelocity() {
                return Math.sqrt(this.state[2] * this.state[2] + this.state[3] * this.state[3]);
            }
            
            // 필터 리셋
            reset() {
                this.initialized = false;
                this.lastTime = null;
                this.state = [0, 0, 0, 0];
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10]
                ];
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const startButton = document.getElementById('start-button');
            const appStatus = document.getElementById('app-status');
            const stateDisplay = document.getElementById('state-display');
            const stuckDisplay = document.getElementById('stuck-display');
            const currentMeterDisplay = document.getElementById('current-meter-display');
            const distanceDisplay = document.getElementById('distance-display');
            const controlSection = document.getElementById('control-section');
            const rssiInput = document.getElementById('rssi-input');
            const submitRssiButton = document.getElementById('submit-rssi-button');
            const totalDistanceDisplay = document.getElementById('total-distance-display');
            const bestSignalDisplay = document.getElementById('best-signal-display');
            const velocityDisplay = document.getElementById('velocity-display');
            const filterStatus = document.getElementById('filter-status');
            const logSection = document.getElementById('log-section');
            const downloadLogButton = document.getElementById('download-log-button');
            const logCount = document.getElementById('log-count');
            const bearingDisplay = document.getElementById('bearing-display');
            const phoneHeadingDisplay = document.getElementById('phone-heading');
            const directionArrow = document.getElementById('direction-arrow');
            
            let logData = [];
            let originLat, originLon, algo;
            let isWaitingForRssi = false;
            const EARTH_RADIUS = 6378137.0;
            let camera = { x: 0, y: 0, zoom: 25 };
            
            // 방향 관련 변수
            let phoneHeading = 0;  // 휴대폰 방향 (나침반)
            let targetBearing = 0; // 목표 지점 방향
            
            // 칼만 필터 인스턴스 생성
            let kalmanFilter = new KalmanFilter();

            const PARAMS = {
                ARRIVAL_DISTANCE: 1.5,
                ASCENT_THRESHOLD: -80.0,
                TARGET_THRESHOLD: -35.0,
                SIGNAL_PINPOINT: -45.0,   DIST_PINPOINT: 0.7,
                SIGNAL_NEAR: -65.0,       DIST_NEAR: 2.0,
                SIGNAL_MID: -75.0,        DIST_MID: 4.0,
                DIST_FAR: 8.0,
                STUCK_THRESHOLD: 4,
                ESCAPE_DISTANCE: 7.0,
                RSSI_BUFFER_SIZE: 3,
                RSSI_IMPROVEMENT_THRESHOLD: 1.0,
                STATIONARY_SPEED_THRESHOLD: 0.5,
            };

            const vec = { 
                create: (x, y) => ({ x, y }), 
                add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }), 
                mul: (v, s) => ({ x: v.x * s, y: v.y * s }), 
                rotate: (v, angleRad) => ({ 
                    x: v.x * Math.cos(angleRad) - v.y * Math.sin(angleRad), 
                    y: v.x * Math.sin(angleRad) + v.y * Math.cos(angleRad) 
                }) 
            };
            
            function latlonToMeters(lat, lon) {
                if (!originLat) return vec.create(0, 0);
                const dx = (lon - originLon) * (EARTH_RADIUS * Math.cos(originLat * Math.PI / 180)) * (Math.PI / 180);
                const dy = (lat - originLat) * EARTH_RADIUS * (Math.PI / 180);
                return vec.create(dx, dy);
            }

            // 방향 계산 함수
            function calculateBearing(from, to) {
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const bearing = Math.atan2(dx, dy) * 180 / Math.PI;
                return (bearing + 360) % 360;
            }

            // 방향 표시 업데이트
            function updateDirection() {
                if (!algo || !algo.pos || !algo.waypoint) return;
                
                // 목표 방향 계산
                targetBearing = calculateBearing(algo.pos, algo.waypoint);
                bearingDisplay.textContent = `${targetBearing.toFixed(0)}°`;
                
                // 상대적 방향 계산 (휴대폰 방향 대비)
                const relativeBearing = (targetBearing - phoneHeading + 360) % 360;
                
                // 화살표 회전
                directionArrow.style.transform = `translate(-50%, -100%) rotate(${relativeBearing}deg)`;
            }

            // 초기값 설정 함수
            function setInitialValues() {
                currentMeterDisplay.textContent = "(0.0, 0.0)m";
                distanceDisplay.textContent = "0.0 m";
                totalDistanceDisplay.textContent = "0.0 m";
                stateDisplay.textContent = "IDLE";
                stuckDisplay.textContent = "0";
                bestSignalDisplay.textContent = "-100.0 dBm";
                velocityDisplay.textContent = "0.00 m/s";
                filterStatus.textContent = "초기화 중";
                bearingDisplay.textContent = "0°";
                phoneHeadingDisplay.textContent = "0°";
                
                // 화살표 북쪽 방향으로 초기화
                directionArrow.style.transform = `translate(-50%, -100%) rotate(0deg)`;
            }

            class HomingAlgorithm {
                constructor(startPos, params) { 
                    Object.assign(this, { 
                        pos: startPos, waypoint: startPos, path: [startPos], params, isFinished: false, 
                        state: "IDLE", lastSmoothedSignal: -100.0, stuck_counter: 0, 
                        best_known_pos: startPos, best_known_signal: -100.0, 
                        ascentDirection: vec.create(1, 0), rssiBuffer: [],
                    }); 
                }
                decideAction(rssi) {
                    if (this.isFinished) return;
                    this.rssiBuffer.push(rssi);
                    if (this.rssiBuffer.length > this.params.RSSI_BUFFER_SIZE) this.rssiBuffer.shift();
                    const smoothedRssi = this.rssiBuffer.reduce((a, b) => a + b, 0) / this.rssiBuffer.length;
                    
                    if (smoothedRssi > this.best_known_signal) { this.best_known_signal = smoothedRssi; this.best_known_pos = this.pos; }
                    if (smoothedRssi >= this.params.TARGET_THRESHOLD) { this.state = "FINISHED"; this.isFinished = true; return; }
                    if (this.state === "IDLE") this._executeIdle(smoothedRssi); 
                    else if (this.state === "ADAPTIVE_ASCENT") this._executeAdaptiveAscent(smoothedRssi); 
                    else if (this.state === "ESCAPING") this._executeEscaping(smoothedRssi);
                    this.lastSmoothedSignal = smoothedRssi;
                }
                getTotalDistance() {
                    let total = 0;
                    for (let i = 1; i < this.path.length; i++) total += Math.hypot(this.path[i].x - this.path[i-1].x, this.path[i].y - this.path[i-1].y);
                    return total;
                }
                _getAdaptiveDistance(signal) {
                    if (signal > this.params.SIGNAL_PINPOINT) return this.params.DIST_PINPOINT;
                    if (signal > this.params.SIGNAL_NEAR) return this.params.DIST_NEAR;
                    if (signal > this.params.SIGNAL_MID) return this.params.DIST_MID;
                    return this.params.DIST_FAR;
                }
                _executeIdle(rssi) {
                    if (rssi > this.params.ASCENT_THRESHOLD) { 
                        this.state = "ADAPTIVE_ASCENT"; 
                        const angle = Math.random() * Math.PI * 2; this.ascentDirection = vec.create(Math.cos(angle), Math.sin(angle)); 
                        this._executeAdaptiveAscent(rssi); 
                    } else { this.waypoint = this.pos; }
                }
                _executeAdaptiveAscent(rssi) {
                    if (rssi > this.lastSmoothedSignal + this.params.RSSI_IMPROVEMENT_THRESHOLD) {
                        this.stuck_counter = 0; 
                        const stepDistance = this._getAdaptiveDistance(rssi); 
                        this.waypoint = vec.add(this.pos, vec.mul(this.ascentDirection, stepDistance)); 
                    } else { 
                        this.stuck_counter++; 
                        if (this.stuck_counter > this.params.STUCK_THRESHOLD) { 
                            this.state = "ESCAPING"; this.waypoint = this.best_known_pos; return; 
                        } 
                        this.waypoint = this.pos; 
                        this.ascentDirection = vec.rotate(this.ascentDirection, Math.PI / 2.5);
                    }
                }
                _executeEscaping(rssi) { 
                    const angle = Math.random() * Math.PI * 2; 
                    this.ascentDirection = vec.create(Math.cos(angle), Math.sin(angle)); 
                    this.waypoint = vec.add(this.best_known_pos, vec.mul(this.ascentDirection, this.params.ESCAPE_DISTANCE)); 
                    this.state = "ADAPTIVE_ASCENT"; this.stuck_counter = 0; 
                }
                updatePosition(newPos) {
                    if (!this.path.length) this.path.push(newPos);
                    const lastPathPoint = this.path[this.path.length - 1];
                    if (Math.hypot(lastPathPoint.x - newPos.x, lastPathPoint.y - newPos.y) < 0.1) return;
                    this.pos = newPos; this.path.push(newPos);
                }
            }

            function draw() {
                if (!algo) return;
                const w = canvas.width, h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                camera.x += (algo.pos.x - camera.x) * 0.1; camera.y += (algo.pos.y - camera.y) * 0.1;
                ctx.save();
                ctx.translate(w / 2, h / 2); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);
                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)"; ctx.lineWidth = 1 / camera.zoom;
                const gridSize = 10;
                const viewBounds = { left: camera.x - (w / 2 / camera.zoom), right: camera.x + (w / 2 / camera.zoom), top: camera.y - (h / 2 / camera.zoom), bottom: camera.y + (h / 2 / camera.zoom) };
                for (let x = Math.floor(viewBounds.left / gridSize) * gridSize; x < viewBounds.right; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, viewBounds.top); ctx.lineTo(x, viewBounds.bottom); ctx.stroke(); }
                for (let y = Math.floor(viewBounds.top / gridSize) * gridSize; y < viewBounds.bottom; y += gridSize) { ctx.beginPath(); ctx.moveTo(viewBounds.left, y); ctx.lineTo(viewBounds.right, y); ctx.stroke(); }
                if (algo.path.length > 1) {
                    ctx.strokeStyle = "#4A5568"; ctx.lineWidth = 2 / camera.zoom; ctx.beginPath();
                    ctx.moveTo(algo.path[0].x, algo.path[0].y);
                    for (let i = 1; i < algo.path.length; i++) { ctx.lineTo(algo.path[i].x, algo.path[i].y); }
                    ctx.stroke();
                }
                ctx.font = `${12 / camera.zoom}px Arial`; ctx.fillStyle = "#FBBF24"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText("★", algo.best_known_pos.x, algo.best_known_pos.y);
                ctx.fillStyle = "#4299E1"; ctx.beginPath(); ctx.arc(algo.waypoint.x, algo.waypoint.y, 0.4, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#48BB78"; ctx.beginPath(); ctx.arc(algo.pos.x, algo.pos.y, 0.4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                requestAnimationFrame(draw);
            }

            // 핵심 수정: finder.html과 동일한 구조로 handleGpsSuccess 수정
            function handleGpsSuccess(position) {
                // 원점 설정
                if (!originLat) {
                    originLat = position.coords.latitude; 
                    originLon = position.coords.longitude;
                    appStatus.textContent = "원점 설정 완료. 테스트를 시작하세요.";
                    startButton.style.display = 'block'; 
                    return;
                }
                
                if (!algo) return;
                
                // 핵심: 매번 좌표 변환 + 칼만 필터 + 무조건 위치 업데이트!
                const rawPosMeters = latlonToMeters(position.coords.latitude, position.coords.longitude);
                const filteredPos = kalmanFilter.update([rawPosMeters.x, rawPosMeters.y]);
                const currentPosMeters = vec.create(filteredPos[0], filteredPos[1]);
                
                // 속도 조건 체크 없이 무조건 위치 업데이트 (finder.html 방식)
                algo.updatePosition(currentPosMeters);
                
                // UI 상태 정보 즉시 업데이트
                stateDisplay.textContent = algo.state; 
                stuckDisplay.textContent = algo.stuck_counter;
                currentMeterDisplay.textContent = `(${currentPosMeters.x.toFixed(1)}, ${currentPosMeters.y.toFixed(1)})m`;
                const dist = Math.hypot(algo.waypoint.x - currentPosMeters.x, algo.waypoint.y - currentPosMeters.y);
                distanceDisplay.textContent = `${dist.toFixed(1)} m`;
                totalDistanceDisplay.textContent = `${algo.getTotalDistance().toFixed(1)} m`;
                bestSignalDisplay.textContent = `${algo.best_known_signal.toFixed(1)} dBm`;
                
                // 칼만 필터 상태 업데이트
                velocityDisplay.textContent = `${kalmanFilter.getVelocity().toFixed(2)} m/s`;
                filterStatus.textContent = kalmanFilter.initialized ? "정상 작동" : "초기화 중";
                
                // 방향 업데이트
                updateDirection();
                
                // 목표 도착 체크
                if (dist < PARAMS.ARRIVAL_DISTANCE && !isWaitingForRssi) {
                    isWaitingForRssi = true; 
                    controlSection.style.display = 'block';
                    appStatus.textContent = "목표 도착! RSSI를 입력하세요."; 
                    rssiInput.focus();
                }
            }

            // 휴대폰 방향 감지
            function handleOrientationChange(event) {
                if (event.alpha !== null) {
                    phoneHeading = event.alpha;
                    phoneHeadingDisplay.textContent = `${phoneHeading.toFixed(0)}°`;
                    updateDirection();
                }
            }

            // Device Orientation API 권한 요청
            async function requestOrientationPermission() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientationChange);
                        } else {
                            console.log('Device orientation permission denied');
                        }
                    } catch (error) {
                        console.log('Device orientation not supported');
                    }
                } else {
                    window.addEventListener('deviceorientation', handleOrientationChange);
                }
            }
            
            startButton.addEventListener('click', () => {
                if (!originLat) { 
                    alert("아직 GPS 원점이 설정되지 않았습니다. 잠시만 기다려주세요."); 
                    return; 
                }
                
                // 알고리즘 초기화
                algo = new HomingAlgorithm(vec.create(0, 0), PARAMS);
                
                // 칼만 필터 초기화
                kalmanFilter.reset();
                
                // 로그 초기화
                logData = []; 
                logCount.textContent = '0';
                logSection.style.display = 'block'; 
                
                // UI 상태 변경
                isWaitingForRssi = true; 
                startButton.style.display = 'none'; 
                controlSection.style.display = 'block';
                appStatus.textContent = "시작점 RSSI를 입력하세요.";
                
                // 방향 센서 권한 요청
                requestOrientationPermission();
                
                // 렌더링 시작
                requestAnimationFrame(draw);
            });

            submitRssiButton.addEventListener('click', () => {
                const rssiValue = parseFloat(rssiInput.value);
                if (isNaN(rssiValue)) { 
                    alert("유효한 RSSI 값을 입력하세요."); 
                    return; 
                }
                
                // 로그 엔트리 생성
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    rssi_input: rssiValue,
                    state_before: algo.state,
                    pos_x: algo.pos.x.toFixed(2),
                    pos_y: algo.pos.y.toFixed(2),
                    waypoint_x_before: algo.waypoint.x.toFixed(2),
                    waypoint_y_before: algo.waypoint.y.toFixed(2),
                    stuck_counter: algo.stuck_counter,
                    estimated_velocity: kalmanFilter.getVelocity().toFixed(2),
                    filter_initialized: kalmanFilter.initialized,
                    phone_heading: phoneHeading.toFixed(1),
                    target_bearing: targetBearing.toFixed(1)
                };
                
                algo.decideAction(rssiValue);

                logEntry.state_after = algo.state;
                logEntry.waypoint_x_after = algo.waypoint.x.toFixed(2);
                logEntry.waypoint_y_after = algo.waypoint.y.toFixed(2);
                logData.push(logEntry);
                logCount.textContent = logData.length;
                
                rssiInput.value = '';
                if (algo.isFinished) {
                    appStatus.textContent = "목표 지점 도착! 테스트 종료."; 
                    controlSection.style.display = 'none';
                } else {
                    isWaitingForRssi = false; 
                    controlSection.style.display = 'none';
                    appStatus.textContent = "다음 목표 계산 완료. 이동하세요.";
                }
            });

            downloadLogButton.addEventListener('click', () => {
                if (logData.length === 0) {
                    alert("기록된 로그 데이터가 없습니다.");
                    return;
                }
                const header = Object.keys(logData[0]).join(',');
                const rows = logData.map(row => Object.values(row).join(','));
                const csvContent = "data:text/csv;charset=utf-8," + header + "\n" + rows.join("\n");
                
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "gps_test_fixed_reception_log.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
            
            function setupCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth; 
                canvas.height = container.clientHeight;
            }

            // 페이지 로드시 초기값 설정
            setInitialValues();

            window.addEventListener('resize', setupCanvas);
            setupCanvas();

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(
                    handleGpsSuccess, 
                    (err) => { 
                        appStatus.textContent = `GPS 오류: ${err.message}`;
                        console.error('GPS Error:', err);
                    }, 
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
                );
                startButton.style.display = 'none';
            } else {
                appStatus.textContent = "이 브라우저에서는 GPS를 지원하지 않습니다.";
            }
        });
    </script>
</body>
</html>
