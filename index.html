<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GPS ë„ë³´ í…ŒìŠ¤í„° (ì•ˆì •í™” ë²„ì „)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .btn:active { transform: scale(0.97); }
        .map-canvas { background-color: #1a202c; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center h-screen p-2 sm:p-4">

    <div class="w-full max-w-lg mx-auto flex flex-col h-full">
        <header class="text-center py-2">
            <h1 class="text-2xl font-bold text-cyan-400">GPS ë„ë³´ í…ŒìŠ¤í„° (ì•ˆì •í™” ë²„ì „)</h1>
            <p id="app-status" class="text-gray-400 text-sm">GPS ì‹ í˜¸ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
        </header>

        <div class="relative w-full flex-grow rounded-xl overflow-hidden border-2 border-cyan-500/30 my-2">
            <canvas id="mapCanvas" class="map-canvas"></canvas>
            <div class="absolute bottom-2 left-2 bg-black/50 p-2 rounded-lg text-xs leading-tight">
                <p><span class="text-green-400">ğŸŸ¢</span> í˜„ì¬ ìœ„ì¹˜ (ìŠ¤ë¬´ë”©)</p>
                <p><span class="text-blue-400">ğŸ”µ</span> ì›¨ì´í¬ì¸íŠ¸</p>
                <p><span class="text-yellow-400">â˜…</span> ìµœê³  ì‹ í˜¸ ì§€ì </p>
            </div>
            <div class="absolute top-2 right-2 bg-black/50 p-2 rounded-full text-xs text-center font-sans">
                <div class="font-bold">N</div>
                <div>â¬†</div>
            </div>
        </div>

        <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
            <div id="status-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-3 text-sm mb-4">
                <div><span class="text-gray-400">ìƒëŒ€ ìœ„ì¹˜:</span> <span id="current-meter-display" class="font-mono text-white">-</span></div>
                <div><span class="text-gray-400">ëª©í‘œê¹Œì§€:</span> <span id="distance-display" class="font-mono font-bold text-green-400">-</span></div>
                <div><span class="text-gray-400">ì´ ì´ë™ ê±°ë¦¬:</span> <span id="total-distance-display" class="font-mono text-white">-</span></div>
                <div><span class="text-gray-400">ì•Œê³ ë¦¬ì¦˜:</span> <span id="state-display" class="font-mono text-yellow-300">-</span></div>
                <div><span class="text-gray-400">Stuck:</span> <span id="stuck-display" class="font-mono text-red-400">-</span></div>
                <div><span class="text-gray-400">ìµœê³  ì‹ í˜¸:</span> <span id="best-signal-display" class="font-mono text-yellow-400">-</span></div>
            </div>
            
            <div id="control-section" class="hidden">
                <label for="rssi-input" class="block mb-2 text-base font-medium text-green-300">ëª©í‘œ ë„ì°©! RSSI ê°’ì„ ì…ë ¥í•˜ì„¸ìš”:</label>
                <input type="number" id="rssi-input" class="bg-gray-700 border border-gray-600 text-white text-2xl font-bold rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-full p-3 text-center mb-3" placeholder="-55">
                <button id="submit-rssi-button" class="btn w-full text-white bg-green-500 hover:bg-green-600 font-bold rounded-lg text-lg px-5 py-3 transition-transform">
                    ë‹¤ìŒ ëª©í‘œ ê³„ì‚°
                </button>
            </div>
             <button id="start-button" class="btn w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-6 rounded-lg text-lg">í…ŒìŠ¤íŠ¸ ì‹œì‘</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const startButton = document.getElementById('start-button');
            const appStatus = document.getElementById('app-status');
            const stateDisplay = document.getElementById('state-display');
            const stuckDisplay = document.getElementById('stuck-display');
            const currentMeterDisplay = document.getElementById('current-meter-display');
            const distanceDisplay = document.getElementById('distance-display');
            const controlSection = document.getElementById('control-section');
            const rssiInput = document.getElementById('rssi-input');
            const submitRssiButton = document.getElementById('submit-rssi-button');
            const totalDistanceDisplay = document.getElementById('total-distance-display');
            const bestSignalDisplay = document.getElementById('best-signal-display');

            let originLat, originLon, algo;
            let isWaitingForRssi = false;
            const EARTH_RADIUS = 6378137.0;
            let camera = { x: 0, y: 0, zoom: 25 };
            
            // --- ë°ì´í„° ì•ˆì •í™”ë¥¼ ìœ„í•œ ë²„í¼ ---
            const gpsBuffer = [];

            // --- í˜„ì‹¤ ë°ì´í„° ê¸°ë°˜ íŒŒë¼ë¯¸í„° ìˆ˜ì • ---
            const PARAMS = {
                ARRIVAL_DISTANCE: 1.5,      // ë„ì°© ì¸ì • ê±°ë¦¬ (ì¡°ê¸ˆ ì¤„ì„)
                ASCENT_THRESHOLD: -80.0,    // ì´ ì‹ í˜¸ ê°•ë„ë¶€í„° íƒìƒ‰ ì‹œì‘ (í˜„ì‹¤ ë°˜ì˜)
                TARGET_THRESHOLD: -35.0,    // ëª©í‘œ ì‹ í˜¸ ê°•ë„ (í˜„ì‹¤ ë°˜ì˜)
                
                // ì‹ í˜¸ ê°•ë„ë³„ ì´ë™ ê±°ë¦¬ ì¬ì„¤ì •
                SIGNAL_PINPOINT: -45.0,   DIST_PINPOINT: 0.7,   // 70cm
                SIGNAL_NEAR: -65.0,       DIST_NEAR: 2.0,     // 2m
                SIGNAL_MID: -75.0,        DIST_MID: 4.0,      // 4m
                DIST_FAR: 8.0,            // 8m (ì‹ í˜¸ê°€ -75dBm ë³´ë‹¤ ì•½í•  ë•Œ)

                STUCK_THRESHOLD: 4,       // ê°™ì€ ì¥ì†Œì—ì„œ 4ë²ˆ ì‹ í˜¸ ì•…í™” ì‹œ stuck
                ESCAPE_DISTANCE: 7.0,

                // --- ë°ì´í„° ìŠ¤ë¬´ë”©(ì•ˆì •í™”) íŒŒë¼ë¯¸í„° ì¶”ê°€ ---
                GPS_BUFFER_SIZE: 10,        // ìµœê·¼ 10ê°œì˜ GPS ì¢Œí‘œë¥¼ í‰ê· 
                RSSI_BUFFER_SIZE: 3,        // ìµœê·¼ 3ê°œì˜ RSSI ê°’ì„ í‰ê· 
                RSSI_IMPROVEMENT_THRESHOLD: 1.0, // ì‹ í˜¸ê°€ 1dBm ì´ìƒ 'ëšœë ·í•˜ê²Œ' ì¢‹ì•„ì¡Œì„ ë•Œë§Œ ì¸ì •
            };

            const vec = { create: (x, y) => ({ x, y }), add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }), mul: (v, s) => ({ x: v.x * s, y: v.y * s }), rotate: (v, angleRad) => ({ x: v.x * Math.cos(angleRad) - v.y * Math.sin(angleRad), y: v.x * Math.sin(angleRad) + v.y * Math.cos(angleRad) }) };
            
            function latlonToMeters(lat, lon) {
                if (!originLat) return vec.create(0, 0);
                const dx = (lon - originLon) * (EARTH_RADIUS * Math.cos(originLat * Math.PI / 180)) * (Math.PI / 180);
                const dy = (lat - originLat) * EARTH_RADIUS * (Math.PI / 180);
                return vec.create(dx, dy);
            }

            class HomingAlgorithm {
                constructor(startPos, params) { 
                    Object.assign(this, { 
                        pos: startPos, 
                        waypoint: startPos, 
                        path: [startPos], 
                        params, 
                        isFinished: false, 
                        state: "IDLE", 
                        lastSmoothedSignal: -100.0, // --- ìŠ¤ë¬´ë”©ëœ ê°’ ì €ì¥ ---
                        stuck_counter: 0, 
                        best_known_pos: startPos, 
                        best_known_signal: -100.0, 
                        ascentDirection: vec.create(1, 0),
                        rssiBuffer: [], // --- RSSI ë²„í¼ ì¶”ê°€ ---
                    }); 
                }

                decideAction(rssi) {
                    if (this.isFinished) return;

                    // --- RSSI ì´ë™ í‰ê·  í•„í„°ë§ ---
                    this.rssiBuffer.push(rssi);
                    if (this.rssiBuffer.length > this.params.RSSI_BUFFER_SIZE) {
                        this.rssiBuffer.shift();
                    }
                    const smoothedRssi = this.rssiBuffer.reduce((a, b) => a + b, 0) / this.rssiBuffer.length;
                    // ---

                    if (smoothedRssi > this.best_known_signal) { 
                        this.best_known_signal = smoothedRssi; 
                        this.best_known_pos = this.pos; 
                    }
                    if (smoothedRssi >= this.params.TARGET_THRESHOLD) { 
                        this.state = "FINISHED"; 
                        this.isFinished = true; 
                        return; 
                    }

                    if (this.state === "IDLE") this._executeIdle(smoothedRssi); 
                    else if (this.state === "ADAPTIVE_ASCENT") this._executeAdaptiveAscent(smoothedRssi); 
                    else if (this.state === "ESCAPING") this._executeEscaping(smoothedRssi);
                    
                    this.lastSmoothedSignal = smoothedRssi;
                }

                getTotalDistance() {
                    let total = 0;
                    for (let i = 1; i < this.path.length; i++) {
                        total += Math.hypot(this.path[i].x - this.path[i-1].x, this.path[i].y - this.path[i-1].y);
                    }
                    return total;
                }

                _getAdaptiveDistance(signal) {
                    if (signal > this.params.SIGNAL_PINPOINT) return this.params.DIST_PINPOINT;
                    if (signal > this.params.SIGNAL_NEAR) return this.params.DIST_NEAR;
                    if (signal > this.params.SIGNAL_MID) return this.params.DIST_MID;
                    return this.params.DIST_FAR;
                }

                _executeIdle(rssi) {
                    if (rssi > this.params.ASCENT_THRESHOLD) { 
                        this.state = "ADAPTIVE_ASCENT"; 
                        const angle = Math.random() * Math.PI * 2; 
                        this.ascentDirection = vec.create(Math.cos(angle), Math.sin(angle)); 
                        this._executeAdaptiveAscent(rssi); 
                    } else { 
                        this.waypoint = this.pos; 
                    }
                }

                _executeAdaptiveAscent(rssi) {
                    // --- íŒë‹¨ ë¡œì§ ìˆ˜ì •: 'ëšœë ·í•œ' ì‹ í˜¸ ê°œì„ ì´ ìˆì„ ë•Œë§Œ ì „ì§„ ---
                    if (rssi > this.lastSmoothedSignal + this.params.RSSI_IMPROVEMENT_THRESHOLD) {
                        this.stuck_counter = 0; 
                        const stepDistance = this._getAdaptiveDistance(rssi); 
                        this.waypoint = vec.add(this.pos, vec.mul(this.ascentDirection, stepDistance)); 
                    } else { 
                        this.stuck_counter++; 
                        if (this.stuck_counter > this.params.STUCK_THRESHOLD) { 
                            this.state = "ESCAPING"; 
                            this.waypoint = this.best_known_pos; // ì¼ë‹¨ ìµœê³  ì§€ì ìœ¼ë¡œ í›„í‡´
                            return; 
                        } 
                        // ì„±ê¸‰íˆ ë°©í–¥ì„ í‹€ì§€ ì•Šê³ , í˜„ì¬ ìœ„ì¹˜ì—ì„œ ëŒ€ê¸°í•˜ë©° ë‹¤ë¥¸ ë°©í–¥ì„ ëª¨ìƒ‰
                        this.waypoint = this.pos; 
                        this.ascentDirection = vec.rotate(this.ascentDirection, Math.PI / 2.5); // 90ë„ì— ê°€ê¹ê²Œ ë” ë„“ê²Œ íšŒì „
                    }
                }
                
                _executeEscaping(rssi) { 
                    const angle = Math.random() * Math.PI * 2; 
                    this.ascentDirection = vec.create(Math.cos(angle), Math.sin(angle)); 
                    this.waypoint = vec.add(this.best_known_pos, vec.mul(this.ascentDirection, this.params.ESCAPE_DISTANCE)); 
                    this.state = "ADAPTIVE_ASCENT"; 
                    this.stuck_counter = 0; 
                }

                updatePosition(newPos) {
                    if (!this.path.length) {
                         this.path.push(newPos);
                    }
                    const lastPathPoint = this.path[this.path.length - 1];
                    if (Math.hypot(lastPathPoint.x - newPos.x, lastPathPoint.y - newPos.y) < 0.1) return;
                    this.pos = newPos;
                    this.path.push(newPos);
                }
            }

            function draw() {
                if (!algo) return;
                const w = canvas.width, h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                camera.x += (algo.pos.x - camera.x) * 0.1;
                camera.y += (algo.pos.y - camera.y) * 0.1;

                ctx.save();
                ctx.translate(w / 2, h / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(-camera.x, -camera.y);

                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
                ctx.lineWidth = 1 / camera.zoom;
                const gridSize = 10;
                const viewBounds = { left: camera.x - (w / 2 / camera.zoom), right: camera.x + (w / 2 / camera.zoom), top: camera.y - (h / 2 / camera.zoom), bottom: camera.y + (h / 2 / camera.zoom) };
                for (let x = Math.floor(viewBounds.left / gridSize) * gridSize; x < viewBounds.right; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, viewBounds.top); ctx.lineTo(x, viewBounds.bottom); ctx.stroke(); }
                for (let y = Math.floor(viewBounds.top / gridSize) * gridSize; y < viewBounds.bottom; y += gridSize) { ctx.beginPath(); ctx.moveTo(viewBounds.left, y); ctx.lineTo(viewBounds.right, y); ctx.stroke(); }

                if (algo.path.length > 1) {
                    ctx.strokeStyle = "#4A5568"; ctx.lineWidth = 2 / camera.zoom; ctx.beginPath();
                    ctx.moveTo(algo.path[0].x, algo.path[0].y);
                    for (let i = 1; i < algo.path.length; i++) { ctx.lineTo(algo.path[i].x, algo.path[i].y); }
                    ctx.stroke();
                }
                
                ctx.font = `${12 / camera.zoom}px Arial`; ctx.fillStyle = "#FBBF24"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText("â˜…", algo.best_known_pos.x, algo.best_known_pos.y);
                
                ctx.fillStyle = "#4299E1"; ctx.beginPath(); ctx.arc(algo.waypoint.x, algo.waypoint.y, 0.4, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#48BB78"; ctx.beginPath(); ctx.arc(algo.pos.x, algo.pos.y, 0.4, 0, Math.PI * 2); ctx.fill();

                ctx.restore();
                requestAnimationFrame(draw);
            }

            // --- ì‹¤ì‹œê°„ GPS ì²˜ë¦¬ ë° ì•± ì—…ë°ì´íŠ¸ ë¡œì§ í†µí•© ---
            function handleGpsSuccess(position) {
                if (!originLat) {
                    originLat = position.coords.latitude;
                    originLon = position.coords.longitude;
                    appStatus.textContent = "ì›ì  ì„¤ì • ì™„ë£Œ. í…ŒìŠ¤íŠ¸ë¥¼ ì‹œì‘í•˜ì„¸ìš”.";
                    startButton.style.display = 'block';
                    return;
                }

                // GPS ì´ë™ í‰ê·  í•„í„°ë§
                gpsBuffer.push({ lat: position.coords.latitude, lon: position.coords.longitude });
                if (gpsBuffer.length > PARAMS.GPS_BUFFER_SIZE) {
                    gpsBuffer.shift();
                }
                const avgPos = gpsBuffer.reduce((acc, pos) => ({ lat: acc.lat + pos.lat, lon: acc.lon + pos.lon }), { lat: 0, lon: 0 });
                const avgLat = avgPos.lat / gpsBuffer.length;
                const avgLon = avgPos.lon / gpsBuffer.length;

                if (!algo) return;

                const currentPosMeters = latlonToMeters(avgLat, avgLon);
                algo.updatePosition(currentPosMeters);
                
                // UI ì—…ë°ì´íŠ¸
                stateDisplay.textContent = algo.state;
                stuckDisplay.textContent = algo.stuck_counter;
                currentMeterDisplay.textContent = `(${currentPosMeters.x.toFixed(1)}, ${currentPosMeters.y.toFixed(1)})m`;
                const dist = Math.hypot(algo.waypoint.x - currentPosMeters.x, algo.waypoint.y - currentPosMeters.y);
                distanceDisplay.textContent = `${dist.toFixed(1)} m`;
                totalDistanceDisplay.textContent = `${algo.getTotalDistance().toFixed(1)} m`;
                bestSignalDisplay.textContent = `${algo.best_known_signal.toFixed(1)} dBm`;

                if (dist < PARAMS.ARRIVAL_DISTANCE && !isWaitingForRssi) {
                    isWaitingForRssi = true;
                    controlSection.style.display = 'block';
                    appStatus.textContent = "ëª©í‘œ ë„ì°©! RSSIë¥¼ ì…ë ¥í•˜ì„¸ìš”.";
                    rssiInput.focus();
                }
            }

            startButton.addEventListener('click', () => {
                if (!originLat) { alert("ì•„ì§ GPS ì›ì ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”."); return; }
                algo = new HomingAlgorithm(vec.create(0, 0), PARAMS);
                isWaitingForRssi = true;
                startButton.style.display = 'none';
                controlSection.style.display = 'block';
                appStatus.textContent = "ì‹œì‘ì  RSSIë¥¼ ì…ë ¥í•˜ì„¸ìš”.";
                
                // setIntervalì„ ì œê±°í•˜ê³ , draw ë£¨í”„ ì‹œì‘
                requestAnimationFrame(draw);
            });

            submitRssiButton.addEventListener('click', () => {
                const rssiValue = parseFloat(rssiInput.value);
                if (isNaN(rssiValue)) { alert("ìœ íš¨í•œ RSSI ê°’ì„ ì…ë ¥í•˜ì„¸ìš”."); return; }
                algo.decideAction(rssiValue);
                rssiInput.value = '';
                if (algo.isFinished) {
                    appStatus.textContent = "ëª©í‘œ ì§€ì  ë„ì°©! í…ŒìŠ¤íŠ¸ ì¢…ë£Œ.";
                    controlSection.style.display = 'none';
                    // watchPositionì€ ê³„ì† ì¼œë‘ì–´ ìµœì¢… ìœ„ì¹˜ë¥¼ ë³¼ ìˆ˜ ìˆê²Œ í•¨
                } else {
                    isWaitingForRssi = false;
                    controlSection.style.display = 'none';
                    appStatus.textContent = "ë‹¤ìŒ ëª©í‘œ ê³„ì‚° ì™„ë£Œ. ì´ë™í•˜ì„¸ìš”.";
                }
            });
            
            function setupCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }

            window.addEventListener('resize', setupCanvas);
            setupCanvas();

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(handleGpsSuccess, (err) => appStatus.textContent = `GPS ì˜¤ë¥˜: ${err.message}`, { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
                startButton.style.display = 'none';
            } else {
                appStatus.textContent = "ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” GPSë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
            }
        });
    </script>
</body>
</html>




